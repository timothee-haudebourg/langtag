/// This file is auto-generated by `static-automata`. Do not edit.
pub struct LanguageTag {
	state: u32,
}
impl LanguageTag {
	pub const fn new() -> Self {
		Self { state: 0u32 }
	}
	pub const fn push(&mut self, token: char) -> bool {
		self.state = match self.state {
			0u32 => match token {
				'A' | 'a' => 1u32,
				'B'
				| 'D'
				| 'F'..='H'
				| 'J'..='M'
				| 'O'..='R'
				| 'T'..='W'
				| 'Y'
				| 'b'
				| 'd'
				| 'f'..='h'
				| 'j'..='m'
				| 'o'..='r'
				| 't'..='w'
				| 'y' => 2u32,
				'C' | 'c' => 3u32,
				'E' | 'e' => 4u32,
				'I' | 'i' => 5u32,
				'N' | 'n' => 6u32,
				'S' | 's' => 7u32,
				'X' | 'x' => 8u32,
				'Z' | 'z' => 9u32,
				_ => return false,
			},
			1u32 => match token {
				'A'..='Q' | 'S'..='Z' | 'a'..='q' | 's'..='z' => 10u32,
				'R' | 'r' => 11u32,
				_ => return false,
			},
			2u32 => match token {
				'A'..='Z' | 'a'..='z' => 10u32,
				_ => return false,
			},
			3u32 => match token {
				'A'..='D' | 'F'..='Z' | 'a'..='d' | 'f'..='z' => 10u32,
				'E' | 'e' => 12u32,
				_ => return false,
			},
			4u32 => match token {
				'A'..='M' | 'O'..='Z' | 'a'..='m' | 'o'..='z' => 10u32,
				'N' | 'n' => 13u32,
				_ => return false,
			},
			5u32 => match token {
				'-' => 14u32,
				'A'..='Z' | 'a'..='z' => 10u32,
				_ => return false,
			},
			6u32 => match token {
				'A'..='N' | 'P'..='Z' | 'a'..='n' | 'p'..='z' => 10u32,
				'O' | 'o' => 15u32,
				_ => return false,
			},
			7u32 => match token {
				'A'..='F' | 'H'..='Z' | 'a'..='f' | 'h'..='z' => 10u32,
				'G' | 'g' => 16u32,
				_ => return false,
			},
			8u32 => match token {
				'-' => 17u32,
				'A'..='Z' | 'a'..='z' => 10u32,
				_ => return false,
			},
			9u32 => match token {
				'A'..='G' | 'I'..='Z' | 'a'..='g' | 'i'..='z' => 10u32,
				'H' | 'h' => 18u32,
				_ => return false,
			},
			10u32 => match token {
				'-' => 19u32,
				'A'..='Z' | 'a'..='z' => 20u32,
				_ => return false,
			},
			11u32 => match token {
				'-' => 19u32,
				'A'..='S' | 'U'..='Z' | 'a'..='s' | 'u'..='z' => 20u32,
				'T' | 't' => 176u32,
				_ => return false,
			},
			12u32 => match token {
				'-' => 19u32,
				'A'..='K' | 'M'..='Z' | 'a'..='k' | 'm'..='z' => 20u32,
				'L' | 'l' => 168u32,
				_ => return false,
			},
			13u32 => match token {
				'-' => 161u32,
				'A'..='Z' | 'a'..='z' => 20u32,
				_ => return false,
			},
			14u32 => match token {
				'A' | 'a' => 123u32,
				'B' | 'b' => 124u32,
				'D' | 'd' => 125u32,
				'E' | 'e' => 126u32,
				'H' | 'h' => 127u32,
				'K' | 'k' => 128u32,
				'L' | 'l' => 129u32,
				'M' | 'm' => 130u32,
				'N' | 'n' => 131u32,
				'P' | 'p' => 132u32,
				'T' | 't' => 133u32,
				_ => return false,
			},
			15u32 => match token {
				'-' => 118u32,
				'A'..='Z' | 'a'..='z' => 20u32,
				_ => return false,
			},
			16u32 => match token {
				'-' => 19u32,
				'A'..='M' | 'O'..='Z' | 'a'..='m' | 'o'..='z' => 20u32,
				'N' | 'n' => 106u32,
				_ => return false,
			},
			17u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 64u32,
				_ => return false,
			},
			18u32 => match token {
				'-' => 21u32,
				'A'..='Z' | 'a'..='z' => 20u32,
				_ => return false,
			},
			19u32 => match token {
				'0'..='9' => 22u32,
				'A'..='W' | 'Y'..='Z' | 'a'..='w' | 'y'..='z' => 23u32,
				'X' | 'x' => 24u32,
				_ => return false,
			},
			20u32 => match token {
				'-' => 19u32,
				'A'..='Z' | 'a'..='z' => 25u32,
				_ => return false,
			},
			21u32 => match token {
				'0'..='9' => 22u32,
				'A'..='F'
				| 'I'..='L'
				| 'N'..='W'
				| 'Y'..='Z'
				| 'a'..='f'
				| 'i'..='l'
				| 'n'..='w'
				| 'y'..='z' => 23u32,
				'G' | 'g' => 88u32,
				'H' | 'h' => 89u32,
				'M' | 'm' => 90u32,
				'X' | 'x' => 91u32,
				_ => return false,
			},
			22u32 => match token {
				'-' => 33u32,
				'0'..='9' => 34u32,
				'A'..='Z' | 'a'..='z' => 35u32,
				_ => return false,
			},
			23u32 => match token {
				'-' => 33u32,
				'0'..='9' => 36u32,
				'A'..='Z' | 'a'..='z' => 76u32,
				_ => return false,
			},
			24u32 => match token {
				'-' => 17u32,
				'0'..='9' => 36u32,
				'A'..='Z' | 'a'..='z' => 76u32,
				_ => return false,
			},
			25u32 => match token {
				'-' => 26u32,
				'A'..='Z' | 'a'..='z' => 27u32,
				_ => return false,
			},
			26u32 => match token {
				'0'..='9' => 22u32,
				'A'..='W' | 'Y'..='Z' | 'a'..='w' | 'y'..='z' => 28u32,
				'X' | 'x' => 29u32,
				_ => return false,
			},
			27u32 => match token {
				'-' => 26u32,
				'A'..='Z' | 'a'..='z' => 30u32,
				_ => return false,
			},
			28u32 => match token {
				'-' => 33u32,
				'0'..='9' => 36u32,
				'A'..='Z' | 'a'..='z' => 37u32,
				_ => return false,
			},
			29u32 => match token {
				'-' => 17u32,
				'0'..='9' => 36u32,
				'A'..='Z' | 'a'..='z' => 37u32,
				_ => return false,
			},
			30u32 => match token {
				'-' => 26u32,
				'A'..='Z' | 'a'..='z' => 31u32,
				_ => return false,
			},
			31u32 => match token {
				'-' => 26u32,
				'A'..='Z' | 'a'..='z' => 32u32,
				_ => return false,
			},
			32u32 => match token {
				'-' => 26u32,
				_ => return false,
			},
			33u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 38u32,
				_ => return false,
			},
			34u32 => match token {
				'0'..='9' => 75u32,
				'A'..='Z' | 'a'..='z' => 72u32,
				_ => return false,
			},
			35u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 72u32,
				_ => return false,
			},
			36u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 39u32,
				_ => return false,
			},
			37u32 => match token {
				'-' => 40u32,
				'0'..='9' => 39u32,
				'A'..='Z' | 'a'..='z' => 41u32,
				_ => return false,
			},
			38u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 54u32,
				_ => return false,
			},
			39u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 45u32,
				_ => return false,
			},
			40u32 => match token {
				'0'..='9' => 42u32,
				'A'..='W' | 'Y'..='Z' | 'a'..='w' | 'y'..='z' => 43u32,
				'X' | 'x' => 44u32,
				_ => return false,
			},
			41u32 => match token {
				'0'..='9' => 45u32,
				'A'..='Z' | 'a'..='z' => 46u32,
				_ => return false,
			},
			42u32 => match token {
				'-' => 33u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 35u32,
				_ => return false,
			},
			43u32 => match token {
				'-' => 33u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 36u32,
				_ => return false,
			},
			44u32 => match token {
				'-' => 17u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 36u32,
				_ => return false,
			},
			45u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 47u32,
				_ => return false,
			},
			46u32 => match token {
				'-' => 48u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 47u32,
				_ => return false,
			},
			47u32 => match token {
				'-' => 40u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 51u32,
				_ => return false,
			},
			48u32 => match token {
				'0'..='9' => 22u32,
				'A'..='W' | 'Y'..='Z' | 'a'..='w' | 'y'..='z' => 49u32,
				'X' | 'x' => 50u32,
				_ => return false,
			},
			49u32 => match token {
				'-' => 33u32,
				'0'..='9' => 36u32,
				'A'..='Z' | 'a'..='z' => 74u32,
				_ => return false,
			},
			50u32 => match token {
				'-' => 17u32,
				'0'..='9' => 36u32,
				'A'..='Z' | 'a'..='z' => 74u32,
				_ => return false,
			},
			51u32 => match token {
				'-' => 40u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 52u32,
				_ => return false,
			},
			52u32 => match token {
				'-' => 40u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 53u32,
				_ => return false,
			},
			53u32 => match token {
				'-' => 40u32,
				_ => return false,
			},
			54u32 => match token {
				'-' => 55u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 56u32,
				_ => return false,
			},
			55u32 => match token {
				'0'..='9' | 'A'..='W' | 'Y'..='Z' | 'a'..='w' | 'y'..='z' => 57u32,
				'X' | 'x' => 58u32,
				_ => return false,
			},
			56u32 => match token {
				'-' => 55u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 59u32,
				_ => return false,
			},
			57u32 => match token {
				'-' => 33u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 54u32,
				_ => return false,
			},
			58u32 => match token {
				'-' => 17u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 54u32,
				_ => return false,
			},
			59u32 => match token {
				'-' => 55u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 60u32,
				_ => return false,
			},
			60u32 => match token {
				'-' => 55u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 61u32,
				_ => return false,
			},
			61u32 => match token {
				'-' => 55u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 62u32,
				_ => return false,
			},
			62u32 => match token {
				'-' => 55u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 63u32,
				_ => return false,
			},
			63u32 => match token {
				'-' => 55u32,
				_ => return false,
			},
			64u32 => match token {
				'-' => 17u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 65u32,
				_ => return false,
			},
			65u32 => match token {
				'-' => 17u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 66u32,
				_ => return false,
			},
			66u32 => match token {
				'-' => 17u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 67u32,
				_ => return false,
			},
			67u32 => match token {
				'-' => 17u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 68u32,
				_ => return false,
			},
			68u32 => match token {
				'-' => 17u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 69u32,
				_ => return false,
			},
			69u32 => match token {
				'-' => 17u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 70u32,
				_ => return false,
			},
			70u32 => match token {
				'-' => 17u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 71u32,
				_ => return false,
			},
			71u32 => match token {
				'-' => 17u32,
				_ => return false,
			},
			72u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 73u32,
				_ => return false,
			},
			73u32 => match token {
				'-' => 40u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 47u32,
				_ => return false,
			},
			74u32 => match token {
				'-' => 40u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 39u32,
				_ => return false,
			},
			75u32 => match token {
				'-' => 40u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 73u32,
				_ => return false,
			},
			76u32 => match token {
				'-' => 40u32,
				'0'..='9' => 39u32,
				'A'..='Z' | 'a'..='z' => 77u32,
				_ => return false,
			},
			77u32 => match token {
				'-' => 78u32,
				'0'..='9' => 45u32,
				'A'..='Z' | 'a'..='z' => 46u32,
				_ => return false,
			},
			78u32 => match token {
				'0'..='9' => 22u32,
				'A'..='W' | 'Y'..='Z' | 'a'..='w' | 'y'..='z' => 79u32,
				'X' | 'x' => 80u32,
				_ => return false,
			},
			79u32 => match token {
				'-' => 33u32,
				'0'..='9' => 36u32,
				'A'..='Z' | 'a'..='z' => 81u32,
				_ => return false,
			},
			80u32 => match token {
				'-' => 17u32,
				'0'..='9' => 36u32,
				'A'..='Z' | 'a'..='z' => 81u32,
				_ => return false,
			},
			81u32 => match token {
				'-' => 40u32,
				'0'..='9' => 39u32,
				'A'..='Z' | 'a'..='z' => 82u32,
				_ => return false,
			},
			82u32 => match token {
				'-' => 83u32,
				'0'..='9' => 45u32,
				'A'..='Z' | 'a'..='z' => 46u32,
				_ => return false,
			},
			83u32 => match token {
				'0'..='9' => 22u32,
				'A'..='W' | 'Y'..='Z' | 'a'..='w' | 'y'..='z' => 84u32,
				'X' | 'x' => 85u32,
				_ => return false,
			},
			84u32 => match token {
				'-' => 33u32,
				'0'..='9' => 36u32,
				'A'..='Z' | 'a'..='z' => 86u32,
				_ => return false,
			},
			85u32 => match token {
				'-' => 17u32,
				'0'..='9' => 36u32,
				'A'..='Z' | 'a'..='z' => 86u32,
				_ => return false,
			},
			86u32 => match token {
				'-' => 40u32,
				'0'..='9' => 39u32,
				'A'..='Z' | 'a'..='z' => 87u32,
				_ => return false,
			},
			87u32 => match token {
				'-' => 26u32,
				'0'..='9' => 45u32,
				'A'..='Z' | 'a'..='z' => 46u32,
				_ => return false,
			},
			88u32 => match token {
				'-' => 33u32,
				'0'..='9' => 36u32,
				'A'..='T' | 'V'..='Z' | 'a'..='t' | 'v'..='z' => 76u32,
				'U' | 'u' => 92u32,
				_ => return false,
			},
			89u32 => match token {
				'-' => 33u32,
				'0'..='9' => 36u32,
				'A' | 'a' => 93u32,
				'B'..='Z' | 'b'..='z' => 76u32,
				_ => return false,
			},
			90u32 => match token {
				'-' => 33u32,
				'0'..='9' => 36u32,
				'A'..='H' | 'J'..='Z' | 'a'..='h' | 'j'..='z' => 76u32,
				'I' | 'i' => 94u32,
				_ => return false,
			},
			91u32 => match token {
				'-' => 17u32,
				'0'..='9' => 36u32,
				'A'..='H' | 'J'..='Z' | 'a'..='h' | 'j'..='z' => 76u32,
				'I' | 'i' => 95u32,
				_ => return false,
			},
			92u32 => match token {
				'-' => 40u32,
				'0'..='9' => 39u32,
				'A'..='N' | 'P'..='Z' | 'a'..='n' | 'p'..='z' => 77u32,
				'O' | 'o' => 104u32,
				_ => return false,
			},
			93u32 => match token {
				'-' => 40u32,
				'0'..='9' => 39u32,
				'A'..='J' | 'L'..='Z' | 'a'..='j' | 'l'..='z' => 77u32,
				'K' | 'k' => 102u32,
				_ => return false,
			},
			94u32 => match token {
				'-' => 40u32,
				'0'..='9' => 39u32,
				'A'..='M' | 'O'..='Z' | 'a'..='m' | 'o'..='z' => 77u32,
				'N' | 'n' => 98u32,
				_ => return false,
			},
			95u32 => match token {
				'-' => 40u32,
				'0'..='9' => 39u32,
				'A' | 'a' => 96u32,
				'B'..='Z' | 'b'..='z' => 77u32,
				_ => return false,
			},
			96u32 => match token {
				'-' => 78u32,
				'0'..='9' => 45u32,
				'A'..='M' | 'O'..='Z' | 'a'..='m' | 'o'..='z' => 46u32,
				'N' | 'n' => 97u32,
				_ => return false,
			},
			97u32 => match token {
				'-' => 48u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 47u32,
				_ => return false,
			},
			98u32 => match token {
				'-' => 99u32,
				'0'..='9' => 45u32,
				'A'..='Z' | 'a'..='z' => 46u32,
				_ => return false,
			},
			99u32 => match token {
				'0'..='9' => 22u32,
				'A'..='M' | 'O'..='W' | 'Y'..='Z' | 'a'..='m' | 'o'..='w' | 'y'..='z' => 79u32,
				'N' | 'n' => 100u32,
				'X' | 'x' => 80u32,
				_ => return false,
			},
			100u32 => match token {
				'-' => 33u32,
				'0'..='9' => 36u32,
				'A' | 'a' => 101u32,
				'B'..='Z' | 'b'..='z' => 81u32,
				_ => return false,
			},
			101u32 => match token {
				'-' => 40u32,
				'0'..='9' => 39u32,
				'A'..='Z' | 'a'..='z' => 82u32,
				_ => return false,
			},
			102u32 => match token {
				'-' => 78u32,
				'0'..='9' => 45u32,
				'A'..='J' | 'L'..='Z' | 'a'..='j' | 'l'..='z' => 46u32,
				'K' | 'k' => 103u32,
				_ => return false,
			},
			103u32 => match token {
				'-' => 48u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 47u32,
				_ => return false,
			},
			104u32 => match token {
				'-' => 78u32,
				'0'..='9' => 45u32,
				'A'..='X' | 'Z' | 'a'..='x' | 'z' => 46u32,
				'Y' | 'y' => 105u32,
				_ => return false,
			},
			105u32 => match token {
				'-' => 48u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 47u32,
				_ => return false,
			},
			106u32 => match token {
				'-' => 107u32,
				'A'..='Z' | 'a'..='z' => 25u32,
				_ => return false,
			},
			107u32 => match token {
				'0'..='9' => 22u32,
				'A' | 'D'..='W' | 'Y'..='Z' | 'a' | 'd'..='w' | 'y'..='z' => 23u32,
				'B' | 'b' => 108u32,
				'C' | 'c' => 109u32,
				'X' | 'x' => 24u32,
				_ => return false,
			},
			108u32 => match token {
				'-' => 33u32,
				'0'..='9' => 36u32,
				'A'..='D' | 'F'..='Z' | 'a'..='d' | 'f'..='z' => 76u32,
				'E' | 'e' => 110u32,
				_ => return false,
			},
			109u32 => match token {
				'-' => 33u32,
				'0'..='9' => 36u32,
				'A'..='G' | 'I'..='Z' | 'a'..='g' | 'i'..='z' => 76u32,
				'H' | 'h' => 111u32,
				_ => return false,
			},
			110u32 => match token {
				'-' => 115u32,
				'0'..='9' => 39u32,
				'A'..='Z' | 'a'..='z' => 77u32,
				_ => return false,
			},
			111u32 => match token {
				'-' => 112u32,
				'0'..='9' => 39u32,
				'A'..='Z' | 'a'..='z' => 77u32,
				_ => return false,
			},
			112u32 => match token {
				'0'..='9' => 42u32,
				'A'..='C' | 'E'..='W' | 'Y'..='Z' | 'a'..='c' | 'e'..='w' | 'y'..='z' => 43u32,
				'D' | 'd' => 113u32,
				'X' | 'x' => 44u32,
				_ => return false,
			},
			113u32 => match token {
				'-' => 33u32,
				'0'..='9' | 'A'..='D' | 'F'..='Z' | 'a'..='d' | 'f'..='z' => 36u32,
				'E' | 'e' => 114u32,
				_ => return false,
			},
			114u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 39u32,
				_ => return false,
			},
			115u32 => match token {
				'0'..='9' => 42u32,
				'A'..='E'
				| 'G'..='M'
				| 'O'..='W'
				| 'Y'..='Z'
				| 'a'..='e'
				| 'g'..='m'
				| 'o'..='w'
				| 'y'..='z' => 43u32,
				'F' | 'f' => 116u32,
				'N' | 'n' => 117u32,
				'X' | 'x' => 44u32,
				_ => return false,
			},
			116u32 => match token {
				'-' => 33u32,
				'0'..='9' | 'A'..='Q' | 'S'..='Z' | 'a'..='q' | 's'..='z' => 36u32,
				'R' | 'r' => 114u32,
				_ => return false,
			},
			117u32 => match token {
				'-' => 33u32,
				'0'..='9' | 'A'..='K' | 'M'..='Z' | 'a'..='k' | 'm'..='z' => 36u32,
				'L' | 'l' => 114u32,
				_ => return false,
			},
			118u32 => match token {
				'0'..='9' => 22u32,
				'A'
				| 'C'..='M'
				| 'O'..='W'
				| 'Y'..='Z'
				| 'a'
				| 'c'..='m'
				| 'o'..='w'
				| 'y'..='z' => 23u32,
				'B' | 'b' => 119u32,
				'N' | 'n' => 120u32,
				'X' | 'x' => 24u32,
				_ => return false,
			},
			119u32 => match token {
				'-' => 33u32,
				'0'..='9' => 36u32,
				'A'..='N' | 'P'..='Z' | 'a'..='n' | 'p'..='z' => 76u32,
				'O' | 'o' => 121u32,
				_ => return false,
			},
			120u32 => match token {
				'-' => 33u32,
				'0'..='9' => 36u32,
				'A'..='X' | 'Z' | 'a'..='x' | 'z' => 76u32,
				'Y' | 'y' => 122u32,
				_ => return false,
			},
			121u32 => match token {
				'-' => 40u32,
				'0'..='9' => 39u32,
				'A'..='Z' | 'a'..='z' => 77u32,
				_ => return false,
			},
			122u32 => match token {
				'-' => 40u32,
				'0'..='9' => 39u32,
				'A'..='Z' | 'a'..='z' => 77u32,
				_ => return false,
			},
			123u32 => match token {
				'M' | 'm' => 134u32,
				_ => return false,
			},
			124u32 => match token {
				'N' | 'n' => 135u32,
				_ => return false,
			},
			125u32 => match token {
				'E' | 'e' => 136u32,
				_ => return false,
			},
			126u32 => match token {
				'N' | 'n' => 137u32,
				_ => return false,
			},
			127u32 => match token {
				'A' | 'a' => 138u32,
				_ => return false,
			},
			128u32 => match token {
				'L' | 'l' => 139u32,
				_ => return false,
			},
			129u32 => match token {
				'U' | 'u' => 140u32,
				_ => return false,
			},
			130u32 => match token {
				'I' | 'i' => 141u32,
				_ => return false,
			},
			131u32 => match token {
				'A' | 'a' => 142u32,
				_ => return false,
			},
			132u32 => match token {
				'W' | 'w' => 135u32,
				_ => return false,
			},
			133u32 => match token {
				'A' | 'a' => 143u32,
				'S' | 's' => 144u32,
				_ => return false,
			},
			134u32 => match token {
				'I' | 'i' => 145u32,
				_ => return false,
			},
			135u32 => match token {
				'N' | 'n' => 145u32,
				_ => return false,
			},
			136u32 => match token {
				'F' | 'f' => 157u32,
				_ => return false,
			},
			137u32 => match token {
				'O' | 'o' => 153u32,
				_ => return false,
			},
			138u32 => match token {
				'K' | 'k' => 145u32,
				_ => return false,
			},
			139u32 => match token {
				'I' | 'i' => 150u32,
				_ => return false,
			},
			140u32 => match token {
				'X' | 'x' => 145u32,
				_ => return false,
			},
			141u32 => match token {
				'N' | 'n' => 149u32,
				_ => return false,
			},
			142u32 => match token {
				'V' | 'v' => 146u32,
				_ => return false,
			},
			143u32 => match token {
				'O' | 'Y' | 'o' | 'y' => 145u32,
				_ => return false,
			},
			144u32 => match token {
				'U' | 'u' => 145u32,
				_ => return false,
			},
			146u32 => match token {
				'A' | 'a' => 147u32,
				_ => return false,
			},
			147u32 => match token {
				'J' | 'j' => 148u32,
				_ => return false,
			},
			148u32 => match token {
				'O' | 'o' => 145u32,
				_ => return false,
			},
			149u32 => match token {
				'G' | 'g' => 148u32,
				_ => return false,
			},
			150u32 => match token {
				'N' | 'n' => 151u32,
				_ => return false,
			},
			151u32 => match token {
				'G' | 'g' => 152u32,
				_ => return false,
			},
			152u32 => match token {
				'O' | 'o' => 135u32,
				_ => return false,
			},
			153u32 => match token {
				'C' | 'c' => 154u32,
				_ => return false,
			},
			154u32 => match token {
				'H' | 'h' => 155u32,
				_ => return false,
			},
			155u32 => match token {
				'I' | 'i' => 156u32,
				_ => return false,
			},
			156u32 => match token {
				'A' | 'a' => 135u32,
				_ => return false,
			},
			157u32 => match token {
				'A' | 'a' => 158u32,
				_ => return false,
			},
			158u32 => match token {
				'U' | 'u' => 159u32,
				_ => return false,
			},
			159u32 => match token {
				'L' | 'l' => 160u32,
				_ => return false,
			},
			160u32 => match token {
				'T' | 't' => 145u32,
				_ => return false,
			},
			161u32 => match token {
				'0'..='9' => 22u32,
				'A'..='F' | 'H'..='W' | 'Y'..='Z' | 'a'..='f' | 'h'..='w' | 'y'..='z' => 23u32,
				'G' | 'g' => 162u32,
				'X' | 'x' => 24u32,
				_ => return false,
			},
			162u32 => match token {
				'-' => 33u32,
				'0'..='9' => 36u32,
				'A' | 'C'..='Z' | 'a' | 'c'..='z' => 76u32,
				'B' | 'b' => 163u32,
				_ => return false,
			},
			163u32 => match token {
				'-' => 164u32,
				'0'..='9' => 39u32,
				'A'..='Z' | 'a'..='z' => 77u32,
				_ => return false,
			},
			164u32 => match token {
				'0'..='9' => 42u32,
				'A'..='N' | 'P'..='W' | 'Y'..='Z' | 'a'..='n' | 'p'..='w' | 'y'..='z' => 43u32,
				'O' | 'o' => 165u32,
				'X' | 'x' => 44u32,
				_ => return false,
			},
			165u32 => match token {
				'-' => 33u32,
				'0'..='9' | 'A'..='D' | 'F'..='Z' | 'a'..='d' | 'f'..='z' => 36u32,
				'E' | 'e' => 166u32,
				_ => return false,
			},
			166u32 => match token {
				'0'..='9' | 'A'..='C' | 'E'..='Z' | 'a'..='c' | 'e'..='z' => 39u32,
				'D' | 'd' => 167u32,
				_ => return false,
			},
			167u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 45u32,
				_ => return false,
			},
			168u32 => match token {
				'-' => 169u32,
				'A'..='Z' | 'a'..='z' => 25u32,
				_ => return false,
			},
			169u32 => match token {
				'0'..='9' => 22u32,
				'A'..='F' | 'H'..='W' | 'Y'..='Z' | 'a'..='f' | 'h'..='w' | 'y'..='z' => 23u32,
				'G' | 'g' => 170u32,
				'X' | 'x' => 24u32,
				_ => return false,
			},
			170u32 => match token {
				'-' => 33u32,
				'0'..='9' => 36u32,
				'A' | 'a' => 171u32,
				'B'..='Z' | 'b'..='z' => 76u32,
				_ => return false,
			},
			171u32 => match token {
				'-' => 40u32,
				'0'..='9' => 39u32,
				'A'..='T' | 'V'..='Z' | 'a'..='t' | 'v'..='z' => 77u32,
				'U' | 'u' => 172u32,
				_ => return false,
			},
			172u32 => match token {
				'-' => 78u32,
				'0'..='9' => 45u32,
				'A'..='K' | 'M'..='Z' | 'a'..='k' | 'm'..='z' => 46u32,
				'L' | 'l' => 173u32,
				_ => return false,
			},
			173u32 => match token {
				'-' => 48u32,
				'0'..='9' | 'A'..='H' | 'J'..='Z' | 'a'..='h' | 'j'..='z' => 47u32,
				'I' | 'i' => 174u32,
				_ => return false,
			},
			174u32 => match token {
				'-' => 40u32,
				'0'..='9' | 'A'..='R' | 'T'..='Z' | 'a'..='r' | 't'..='z' => 51u32,
				'S' | 's' => 175u32,
				_ => return false,
			},
			175u32 => match token {
				'-' => 40u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 52u32,
				_ => return false,
			},
			176u32 => match token {
				'-' => 177u32,
				'A'..='Z' | 'a'..='z' => 25u32,
				_ => return false,
			},
			177u32 => match token {
				'0'..='9' => 22u32,
				'A'..='K' | 'M'..='W' | 'Y'..='Z' | 'a'..='k' | 'm'..='w' | 'y'..='z' => 23u32,
				'L' | 'l' => 178u32,
				'X' | 'x' => 24u32,
				_ => return false,
			},
			178u32 => match token {
				'-' => 33u32,
				'0'..='9' => 36u32,
				'A'..='N' | 'P'..='Z' | 'a'..='n' | 'p'..='z' => 76u32,
				'O' | 'o' => 179u32,
				_ => return false,
			},
			179u32 => match token {
				'-' => 40u32,
				'0'..='9' => 39u32,
				'A'..='I' | 'K'..='Z' | 'a'..='i' | 'k'..='z' => 77u32,
				'J' | 'j' => 180u32,
				_ => return false,
			},
			180u32 => match token {
				'-' => 78u32,
				'0'..='9' => 45u32,
				'A' | 'C'..='Z' | 'a' | 'c'..='z' => 46u32,
				'B' | 'b' => 181u32,
				_ => return false,
			},
			181u32 => match token {
				'-' => 48u32,
				'0'..='9' | 'B'..='Z' | 'b'..='z' => 47u32,
				'A' | 'a' => 182u32,
				_ => return false,
			},
			182u32 => match token {
				'-' => 40u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 51u32,
				_ => return false,
			},
			_ => return false,
		};
		true
	}
	pub const fn is_accepting(&self) -> bool {
		matches!(
			self.state,
			10u32
				| 11u32 | 12u32
				| 13u32 | 15u32
				| 16u32 | 18u32
				| 20u32 | 25u32
				| 27u32 | 30u32
				| 31u32 | 32u32
				| 37u32 | 46u32
				| 47u32 | 51u32
				| 52u32 | 53u32
				| 54u32 | 56u32
				| 59u32 | 60u32
				| 61u32 | 62u32
				| 63u32 | 64u32
				| 65u32 | 66u32
				| 67u32 | 68u32
				| 69u32 | 70u32
				| 71u32 | 73u32
				| 74u32 | 75u32
				| 76u32 | 77u32
				| 81u32 | 82u32
				| 86u32 | 87u32
				| 92u32 | 93u32
				| 94u32 | 95u32
				| 96u32 | 97u32
				| 98u32 | 101u32
				| 102u32 | 103u32
				| 104u32 | 105u32
				| 106u32 | 110u32
				| 111u32 | 114u32
				| 121u32 | 122u32
				| 145u32 | 163u32
				| 167u32 | 168u32
				| 171u32 | 172u32
				| 173u32 | 174u32
				| 175u32 | 176u32
				| 179u32 | 180u32
				| 181u32 | 182u32
		)
	}
	pub const fn validate_str(s: &str) -> bool {
		Self::validate_bytes(s.as_bytes())
	}
	pub const fn validate_bytes(bytes: &[u8]) -> bool {
		let mut i = 0;
		let mut automaton = Self::new();
		while i < bytes.len() {
			match ::static_automata::decode_utf8_char(bytes, i) {
				Ok((c, len)) => {
					if !automaton.push(c) {
						return false;
					}
					i += len;
				}
				Err(_) => return false,
			}
		}
		automaton.is_accepting()
	}
}
pub struct Privateuse {
	state: u32,
}
impl Privateuse {
	pub const fn new() -> Self {
		Self { state: 0u32 }
	}
	pub const fn push(&mut self, token: char) -> bool {
		self.state = match self.state {
			0u32 => match token {
				'X' | 'x' => 1u32,
				_ => return false,
			},
			1u32 => match token {
				'-' => 2u32,
				_ => return false,
			},
			2u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 3u32,
				_ => return false,
			},
			3u32 => match token {
				'-' => 2u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 4u32,
				_ => return false,
			},
			4u32 => match token {
				'-' => 2u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 5u32,
				_ => return false,
			},
			5u32 => match token {
				'-' => 2u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 6u32,
				_ => return false,
			},
			6u32 => match token {
				'-' => 2u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 7u32,
				_ => return false,
			},
			7u32 => match token {
				'-' => 2u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 8u32,
				_ => return false,
			},
			8u32 => match token {
				'-' => 2u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 9u32,
				_ => return false,
			},
			9u32 => match token {
				'-' => 2u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 10u32,
				_ => return false,
			},
			10u32 => match token {
				'-' => 2u32,
				_ => return false,
			},
			_ => return false,
		};
		true
	}
	pub const fn is_accepting(&self) -> bool {
		matches!(
			self.state,
			3u32 | 4u32 | 5u32 | 6u32 | 7u32 | 8u32 | 9u32 | 10u32
		)
	}
	pub const fn validate_str(s: &str) -> bool {
		Self::validate_bytes(s.as_bytes())
	}
	pub const fn validate_bytes(bytes: &[u8]) -> bool {
		let mut i = 0;
		let mut automaton = Self::new();
		while i < bytes.len() {
			match ::static_automata::decode_utf8_char(bytes, i) {
				Ok((c, len)) => {
					if !automaton.push(c) {
						return false;
					}
					i += len;
				}
				Err(_) => return false,
			}
		}
		automaton.is_accepting()
	}
}
pub struct PrivateuseSubtag {
	state: u32,
}
impl PrivateuseSubtag {
	pub const fn new() -> Self {
		Self { state: 0u32 }
	}
	pub const fn push(&mut self, token: char) -> bool {
		self.state = match self.state {
			0u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 1u32,
				_ => return false,
			},
			1u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 2u32,
				_ => return false,
			},
			2u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 3u32,
				_ => return false,
			},
			3u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 4u32,
				_ => return false,
			},
			4u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 5u32,
				_ => return false,
			},
			5u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 6u32,
				_ => return false,
			},
			6u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 7u32,
				_ => return false,
			},
			7u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 8u32,
				_ => return false,
			},
			_ => return false,
		};
		true
	}
	pub const fn is_accepting(&self) -> bool {
		matches!(
			self.state,
			1u32 | 2u32 | 3u32 | 4u32 | 5u32 | 6u32 | 7u32 | 8u32
		)
	}
	pub const fn validate_str(s: &str) -> bool {
		Self::validate_bytes(s.as_bytes())
	}
	pub const fn validate_bytes(bytes: &[u8]) -> bool {
		let mut i = 0;
		let mut automaton = Self::new();
		while i < bytes.len() {
			match ::static_automata::decode_utf8_char(bytes, i) {
				Ok((c, len)) => {
					if !automaton.push(c) {
						return false;
					}
					i += len;
				}
				Err(_) => return false,
			}
		}
		automaton.is_accepting()
	}
}
pub struct Langtag {
	state: u32,
}
impl Langtag {
	pub const fn new() -> Self {
		Self { state: 0u32 }
	}
	pub const fn push(&mut self, token: char) -> bool {
		self.state = match self.state {
			0u32 => match token {
				'A'..='Z' | 'a'..='z' => 1u32,
				_ => return false,
			},
			1u32 => match token {
				'A'..='Z' | 'a'..='z' => 2u32,
				_ => return false,
			},
			2u32 => match token {
				'-' => 3u32,
				'A'..='Z' | 'a'..='z' => 4u32,
				_ => return false,
			},
			3u32 => match token {
				'0'..='9' => 5u32,
				'A'..='W' | 'Y'..='Z' | 'a'..='w' | 'y'..='z' => 6u32,
				'X' | 'x' => 7u32,
				_ => return false,
			},
			4u32 => match token {
				'-' => 3u32,
				'A'..='Z' | 'a'..='z' => 8u32,
				_ => return false,
			},
			5u32 => match token {
				'-' => 16u32,
				'0'..='9' => 17u32,
				'A'..='Z' | 'a'..='z' => 18u32,
				_ => return false,
			},
			6u32 => match token {
				'-' => 16u32,
				'0'..='9' => 19u32,
				'A'..='Z' | 'a'..='z' => 60u32,
				_ => return false,
			},
			7u32 => match token {
				'-' => 21u32,
				'0'..='9' => 19u32,
				'A'..='Z' | 'a'..='z' => 60u32,
				_ => return false,
			},
			8u32 => match token {
				'-' => 9u32,
				'A'..='Z' | 'a'..='z' => 10u32,
				_ => return false,
			},
			9u32 => match token {
				'0'..='9' => 5u32,
				'A'..='W' | 'Y'..='Z' | 'a'..='w' | 'y'..='z' => 11u32,
				'X' | 'x' => 12u32,
				_ => return false,
			},
			10u32 => match token {
				'-' => 9u32,
				'A'..='Z' | 'a'..='z' => 13u32,
				_ => return false,
			},
			11u32 => match token {
				'-' => 16u32,
				'0'..='9' => 19u32,
				'A'..='Z' | 'a'..='z' => 20u32,
				_ => return false,
			},
			12u32 => match token {
				'-' => 21u32,
				'0'..='9' => 19u32,
				'A'..='Z' | 'a'..='z' => 20u32,
				_ => return false,
			},
			13u32 => match token {
				'-' => 9u32,
				'A'..='Z' | 'a'..='z' => 14u32,
				_ => return false,
			},
			14u32 => match token {
				'-' => 9u32,
				'A'..='Z' | 'a'..='z' => 15u32,
				_ => return false,
			},
			15u32 => match token {
				'-' => 9u32,
				_ => return false,
			},
			16u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 22u32,
				_ => return false,
			},
			17u32 => match token {
				'0'..='9' => 59u32,
				'A'..='Z' | 'a'..='z' => 56u32,
				_ => return false,
			},
			18u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 56u32,
				_ => return false,
			},
			19u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 23u32,
				_ => return false,
			},
			20u32 => match token {
				'-' => 24u32,
				'0'..='9' => 23u32,
				'A'..='Z' | 'a'..='z' => 25u32,
				_ => return false,
			},
			21u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 48u32,
				_ => return false,
			},
			22u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 38u32,
				_ => return false,
			},
			23u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 29u32,
				_ => return false,
			},
			24u32 => match token {
				'0'..='9' => 26u32,
				'A'..='W' | 'Y'..='Z' | 'a'..='w' | 'y'..='z' => 27u32,
				'X' | 'x' => 28u32,
				_ => return false,
			},
			25u32 => match token {
				'0'..='9' => 29u32,
				'A'..='Z' | 'a'..='z' => 30u32,
				_ => return false,
			},
			26u32 => match token {
				'-' => 16u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 18u32,
				_ => return false,
			},
			27u32 => match token {
				'-' => 16u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 19u32,
				_ => return false,
			},
			28u32 => match token {
				'-' => 21u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 19u32,
				_ => return false,
			},
			29u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 31u32,
				_ => return false,
			},
			30u32 => match token {
				'-' => 32u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 31u32,
				_ => return false,
			},
			31u32 => match token {
				'-' => 24u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 35u32,
				_ => return false,
			},
			32u32 => match token {
				'0'..='9' => 5u32,
				'A'..='W' | 'Y'..='Z' | 'a'..='w' | 'y'..='z' => 33u32,
				'X' | 'x' => 34u32,
				_ => return false,
			},
			33u32 => match token {
				'-' => 16u32,
				'0'..='9' => 19u32,
				'A'..='Z' | 'a'..='z' => 58u32,
				_ => return false,
			},
			34u32 => match token {
				'-' => 21u32,
				'0'..='9' => 19u32,
				'A'..='Z' | 'a'..='z' => 58u32,
				_ => return false,
			},
			35u32 => match token {
				'-' => 24u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 36u32,
				_ => return false,
			},
			36u32 => match token {
				'-' => 24u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 37u32,
				_ => return false,
			},
			37u32 => match token {
				'-' => 24u32,
				_ => return false,
			},
			38u32 => match token {
				'-' => 39u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 40u32,
				_ => return false,
			},
			39u32 => match token {
				'0'..='9' | 'A'..='W' | 'Y'..='Z' | 'a'..='w' | 'y'..='z' => 41u32,
				'X' | 'x' => 42u32,
				_ => return false,
			},
			40u32 => match token {
				'-' => 39u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 43u32,
				_ => return false,
			},
			41u32 => match token {
				'-' => 16u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 38u32,
				_ => return false,
			},
			42u32 => match token {
				'-' => 21u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 38u32,
				_ => return false,
			},
			43u32 => match token {
				'-' => 39u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 44u32,
				_ => return false,
			},
			44u32 => match token {
				'-' => 39u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 45u32,
				_ => return false,
			},
			45u32 => match token {
				'-' => 39u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 46u32,
				_ => return false,
			},
			46u32 => match token {
				'-' => 39u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 47u32,
				_ => return false,
			},
			47u32 => match token {
				'-' => 39u32,
				_ => return false,
			},
			48u32 => match token {
				'-' => 21u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 49u32,
				_ => return false,
			},
			49u32 => match token {
				'-' => 21u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 50u32,
				_ => return false,
			},
			50u32 => match token {
				'-' => 21u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 51u32,
				_ => return false,
			},
			51u32 => match token {
				'-' => 21u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 52u32,
				_ => return false,
			},
			52u32 => match token {
				'-' => 21u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 53u32,
				_ => return false,
			},
			53u32 => match token {
				'-' => 21u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 54u32,
				_ => return false,
			},
			54u32 => match token {
				'-' => 21u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 55u32,
				_ => return false,
			},
			55u32 => match token {
				'-' => 21u32,
				_ => return false,
			},
			56u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 57u32,
				_ => return false,
			},
			57u32 => match token {
				'-' => 24u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 31u32,
				_ => return false,
			},
			58u32 => match token {
				'-' => 24u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 23u32,
				_ => return false,
			},
			59u32 => match token {
				'-' => 24u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 57u32,
				_ => return false,
			},
			60u32 => match token {
				'-' => 24u32,
				'0'..='9' => 23u32,
				'A'..='Z' | 'a'..='z' => 61u32,
				_ => return false,
			},
			61u32 => match token {
				'-' => 62u32,
				'0'..='9' => 29u32,
				'A'..='Z' | 'a'..='z' => 30u32,
				_ => return false,
			},
			62u32 => match token {
				'0'..='9' => 5u32,
				'A'..='W' | 'Y'..='Z' | 'a'..='w' | 'y'..='z' => 63u32,
				'X' | 'x' => 64u32,
				_ => return false,
			},
			63u32 => match token {
				'-' => 16u32,
				'0'..='9' => 19u32,
				'A'..='Z' | 'a'..='z' => 65u32,
				_ => return false,
			},
			64u32 => match token {
				'-' => 21u32,
				'0'..='9' => 19u32,
				'A'..='Z' | 'a'..='z' => 65u32,
				_ => return false,
			},
			65u32 => match token {
				'-' => 24u32,
				'0'..='9' => 23u32,
				'A'..='Z' | 'a'..='z' => 66u32,
				_ => return false,
			},
			66u32 => match token {
				'-' => 67u32,
				'0'..='9' => 29u32,
				'A'..='Z' | 'a'..='z' => 30u32,
				_ => return false,
			},
			67u32 => match token {
				'0'..='9' => 5u32,
				'A'..='W' | 'Y'..='Z' | 'a'..='w' | 'y'..='z' => 68u32,
				'X' | 'x' => 69u32,
				_ => return false,
			},
			68u32 => match token {
				'-' => 16u32,
				'0'..='9' => 19u32,
				'A'..='Z' | 'a'..='z' => 70u32,
				_ => return false,
			},
			69u32 => match token {
				'-' => 21u32,
				'0'..='9' => 19u32,
				'A'..='Z' | 'a'..='z' => 70u32,
				_ => return false,
			},
			70u32 => match token {
				'-' => 24u32,
				'0'..='9' => 23u32,
				'A'..='Z' | 'a'..='z' => 71u32,
				_ => return false,
			},
			71u32 => match token {
				'-' => 9u32,
				'0'..='9' => 29u32,
				'A'..='Z' | 'a'..='z' => 30u32,
				_ => return false,
			},
			_ => return false,
		};
		true
	}
	pub const fn is_accepting(&self) -> bool {
		matches!(
			self.state,
			2u32 | 4u32
				| 8u32 | 10u32
				| 13u32 | 14u32
				| 15u32 | 20u32
				| 30u32 | 31u32
				| 35u32 | 36u32
				| 37u32 | 38u32
				| 40u32 | 43u32
				| 44u32 | 45u32
				| 46u32 | 47u32
				| 48u32 | 49u32
				| 50u32 | 51u32
				| 52u32 | 53u32
				| 54u32 | 55u32
				| 57u32 | 58u32
				| 59u32 | 60u32
				| 61u32 | 65u32
				| 66u32 | 70u32
				| 71u32
		)
	}
	pub const fn validate_str(s: &str) -> bool {
		Self::validate_bytes(s.as_bytes())
	}
	pub const fn validate_bytes(bytes: &[u8]) -> bool {
		let mut i = 0;
		let mut automaton = Self::new();
		while i < bytes.len() {
			match ::static_automata::decode_utf8_char(bytes, i) {
				Ok((c, len)) => {
					if !automaton.push(c) {
						return false;
					}
					i += len;
				}
				Err(_) => return false,
			}
		}
		automaton.is_accepting()
	}
}
pub struct Language {
	state: u32,
}
impl Language {
	pub const fn new() -> Self {
		Self { state: 0u32 }
	}
	pub const fn push(&mut self, token: char) -> bool {
		self.state = match self.state {
			0u32 => match token {
				'A'..='Z' | 'a'..='z' => 1u32,
				_ => return false,
			},
			1u32 => match token {
				'A'..='Z' | 'a'..='z' => 2u32,
				_ => return false,
			},
			2u32 => match token {
				'-' => 3u32,
				'A'..='Z' | 'a'..='z' => 4u32,
				_ => return false,
			},
			3u32 => match token {
				'A'..='Z' | 'a'..='z' => 5u32,
				_ => return false,
			},
			4u32 => match token {
				'-' => 3u32,
				'A'..='Z' | 'a'..='z' => 6u32,
				_ => return false,
			},
			5u32 => match token {
				'A'..='Z' | 'a'..='z' => 11u32,
				_ => return false,
			},
			6u32 => match token {
				'A'..='Z' | 'a'..='z' => 7u32,
				_ => return false,
			},
			7u32 => match token {
				'A'..='Z' | 'a'..='z' => 8u32,
				_ => return false,
			},
			8u32 => match token {
				'A'..='Z' | 'a'..='z' => 9u32,
				_ => return false,
			},
			9u32 => match token {
				'A'..='Z' | 'a'..='z' => 10u32,
				_ => return false,
			},
			11u32 => match token {
				'A'..='Z' | 'a'..='z' => 12u32,
				_ => return false,
			},
			12u32 => match token {
				'-' => 13u32,
				_ => return false,
			},
			13u32 => match token {
				'A'..='Z' | 'a'..='z' => 14u32,
				_ => return false,
			},
			14u32 => match token {
				'A'..='Z' | 'a'..='z' => 15u32,
				_ => return false,
			},
			15u32 => match token {
				'A'..='Z' | 'a'..='z' => 16u32,
				_ => return false,
			},
			16u32 => match token {
				'-' => 17u32,
				_ => return false,
			},
			17u32 => match token {
				'A'..='Z' | 'a'..='z' => 18u32,
				_ => return false,
			},
			18u32 => match token {
				'A'..='Z' | 'a'..='z' => 19u32,
				_ => return false,
			},
			19u32 => match token {
				'A'..='Z' | 'a'..='z' => 10u32,
				_ => return false,
			},
			_ => return false,
		};
		true
	}
	pub const fn is_accepting(&self) -> bool {
		matches!(
			self.state,
			2u32 | 4u32 | 6u32 | 7u32 | 8u32 | 9u32 | 10u32 | 12u32 | 16u32
		)
	}
	pub const fn validate_str(s: &str) -> bool {
		Self::validate_bytes(s.as_bytes())
	}
	pub const fn validate_bytes(bytes: &[u8]) -> bool {
		let mut i = 0;
		let mut automaton = Self::new();
		while i < bytes.len() {
			match ::static_automata::decode_utf8_char(bytes, i) {
				Ok((c, len)) => {
					if !automaton.push(c) {
						return false;
					}
					i += len;
				}
				Err(_) => return false,
			}
		}
		automaton.is_accepting()
	}
}
pub struct Primary {
	state: u32,
}
impl Primary {
	pub const fn new() -> Self {
		Self { state: 0u32 }
	}
	pub const fn push(&mut self, token: char) -> bool {
		self.state = match self.state {
			0u32 => match token {
				'A'..='Z' | 'a'..='z' => 1u32,
				_ => return false,
			},
			1u32 => match token {
				'A'..='Z' | 'a'..='z' => 2u32,
				_ => return false,
			},
			2u32 => match token {
				'A'..='Z' | 'a'..='z' => 3u32,
				_ => return false,
			},
			_ => return false,
		};
		true
	}
	pub const fn is_accepting(&self) -> bool {
		matches!(self.state, 2u32 | 3u32)
	}
	pub const fn validate_str(s: &str) -> bool {
		Self::validate_bytes(s.as_bytes())
	}
	pub const fn validate_bytes(bytes: &[u8]) -> bool {
		let mut i = 0;
		let mut automaton = Self::new();
		while i < bytes.len() {
			match ::static_automata::decode_utf8_char(bytes, i) {
				Ok((c, len)) => {
					if !automaton.push(c) {
						return false;
					}
					i += len;
				}
				Err(_) => return false,
			}
		}
		automaton.is_accepting()
	}
}
pub struct Extlang {
	state: u32,
}
impl Extlang {
	pub const fn new() -> Self {
		Self { state: 0u32 }
	}
	pub const fn push(&mut self, token: char) -> bool {
		self.state = match self.state {
			0u32 => match token {
				'A'..='Z' | 'a'..='z' => 1u32,
				_ => return false,
			},
			1u32 => match token {
				'A'..='Z' | 'a'..='z' => 2u32,
				_ => return false,
			},
			2u32 => match token {
				'A'..='Z' | 'a'..='z' => 3u32,
				_ => return false,
			},
			3u32 => match token {
				'-' => 4u32,
				_ => return false,
			},
			4u32 => match token {
				'A'..='Z' | 'a'..='z' => 5u32,
				_ => return false,
			},
			5u32 => match token {
				'A'..='Z' | 'a'..='z' => 6u32,
				_ => return false,
			},
			6u32 => match token {
				'A'..='Z' | 'a'..='z' => 7u32,
				_ => return false,
			},
			7u32 => match token {
				'-' => 8u32,
				_ => return false,
			},
			8u32 => match token {
				'A'..='Z' | 'a'..='z' => 9u32,
				_ => return false,
			},
			9u32 => match token {
				'A'..='Z' | 'a'..='z' => 10u32,
				_ => return false,
			},
			10u32 => match token {
				'A'..='Z' | 'a'..='z' => 11u32,
				_ => return false,
			},
			_ => return false,
		};
		true
	}
	pub const fn is_accepting(&self) -> bool {
		matches!(self.state, 3u32 | 7u32 | 11u32)
	}
	pub const fn validate_str(s: &str) -> bool {
		Self::validate_bytes(s.as_bytes())
	}
	pub const fn validate_bytes(bytes: &[u8]) -> bool {
		let mut i = 0;
		let mut automaton = Self::new();
		while i < bytes.len() {
			match ::static_automata::decode_utf8_char(bytes, i) {
				Ok((c, len)) => {
					if !automaton.push(c) {
						return false;
					}
					i += len;
				}
				Err(_) => return false,
			}
		}
		automaton.is_accepting()
	}
}
pub struct ExtlangTag {
	state: u32,
}
impl ExtlangTag {
	pub const fn new() -> Self {
		Self { state: 0u32 }
	}
	pub const fn push(&mut self, token: char) -> bool {
		self.state = match self.state {
			0u32 => match token {
				'A'..='Z' | 'a'..='z' => 1u32,
				_ => return false,
			},
			1u32 => match token {
				'A'..='Z' | 'a'..='z' => 2u32,
				_ => return false,
			},
			2u32 => match token {
				'A'..='Z' | 'a'..='z' => 3u32,
				_ => return false,
			},
			_ => return false,
		};
		true
	}
	pub const fn is_accepting(&self) -> bool {
		matches!(self.state, 3u32)
	}
	pub const fn validate_str(s: &str) -> bool {
		Self::validate_bytes(s.as_bytes())
	}
	pub const fn validate_bytes(bytes: &[u8]) -> bool {
		let mut i = 0;
		let mut automaton = Self::new();
		while i < bytes.len() {
			match ::static_automata::decode_utf8_char(bytes, i) {
				Ok((c, len)) => {
					if !automaton.push(c) {
						return false;
					}
					i += len;
				}
				Err(_) => return false,
			}
		}
		automaton.is_accepting()
	}
}
pub struct Script {
	state: u32,
}
impl Script {
	pub const fn new() -> Self {
		Self { state: 0u32 }
	}
	pub const fn push(&mut self, token: char) -> bool {
		self.state = match self.state {
			0u32 => match token {
				'A'..='Z' | 'a'..='z' => 1u32,
				_ => return false,
			},
			1u32 => match token {
				'A'..='Z' | 'a'..='z' => 2u32,
				_ => return false,
			},
			2u32 => match token {
				'A'..='Z' | 'a'..='z' => 3u32,
				_ => return false,
			},
			3u32 => match token {
				'A'..='Z' | 'a'..='z' => 4u32,
				_ => return false,
			},
			_ => return false,
		};
		true
	}
	pub const fn is_accepting(&self) -> bool {
		matches!(self.state, 4u32)
	}
	pub const fn validate_str(s: &str) -> bool {
		Self::validate_bytes(s.as_bytes())
	}
	pub const fn validate_bytes(bytes: &[u8]) -> bool {
		let mut i = 0;
		let mut automaton = Self::new();
		while i < bytes.len() {
			match ::static_automata::decode_utf8_char(bytes, i) {
				Ok((c, len)) => {
					if !automaton.push(c) {
						return false;
					}
					i += len;
				}
				Err(_) => return false,
			}
		}
		automaton.is_accepting()
	}
}
pub struct Region {
	state: u32,
}
impl Region {
	pub const fn new() -> Self {
		Self { state: 0u32 }
	}
	pub const fn push(&mut self, token: char) -> bool {
		self.state = match self.state {
			0u32 => match token {
				'0'..='9' => 1u32,
				'A'..='Z' | 'a'..='z' => 2u32,
				_ => return false,
			},
			1u32 => match token {
				'0'..='9' => 3u32,
				_ => return false,
			},
			2u32 => match token {
				'A'..='Z' | 'a'..='z' => 4u32,
				_ => return false,
			},
			3u32 => match token {
				'0'..='9' => 4u32,
				_ => return false,
			},
			_ => return false,
		};
		true
	}
	pub const fn is_accepting(&self) -> bool {
		matches!(self.state, 4u32)
	}
	pub const fn validate_str(s: &str) -> bool {
		Self::validate_bytes(s.as_bytes())
	}
	pub const fn validate_bytes(bytes: &[u8]) -> bool {
		let mut i = 0;
		let mut automaton = Self::new();
		while i < bytes.len() {
			match ::static_automata::decode_utf8_char(bytes, i) {
				Ok((c, len)) => {
					if !automaton.push(c) {
						return false;
					}
					i += len;
				}
				Err(_) => return false,
			}
		}
		automaton.is_accepting()
	}
}
pub struct Variant {
	state: u32,
}
impl Variant {
	pub const fn new() -> Self {
		Self { state: 0u32 }
	}
	pub const fn push(&mut self, token: char) -> bool {
		self.state = match self.state {
			0u32 => match token {
				'0'..='9' => 1u32,
				'A'..='Z' | 'a'..='z' => 2u32,
				_ => return false,
			},
			1u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 3u32,
				_ => return false,
			},
			2u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 4u32,
				_ => return false,
			},
			3u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 11u32,
				_ => return false,
			},
			4u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 5u32,
				_ => return false,
			},
			5u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 6u32,
				_ => return false,
			},
			6u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 7u32,
				_ => return false,
			},
			7u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 8u32,
				_ => return false,
			},
			8u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 9u32,
				_ => return false,
			},
			9u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 10u32,
				_ => return false,
			},
			11u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 12u32,
				_ => return false,
			},
			12u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 7u32,
				_ => return false,
			},
			_ => return false,
		};
		true
	}
	pub const fn is_accepting(&self) -> bool {
		matches!(self.state, 7u32 | 8u32 | 9u32 | 10u32 | 12u32)
	}
	pub const fn validate_str(s: &str) -> bool {
		Self::validate_bytes(s.as_bytes())
	}
	pub const fn validate_bytes(bytes: &[u8]) -> bool {
		let mut i = 0;
		let mut automaton = Self::new();
		while i < bytes.len() {
			match ::static_automata::decode_utf8_char(bytes, i) {
				Ok((c, len)) => {
					if !automaton.push(c) {
						return false;
					}
					i += len;
				}
				Err(_) => return false,
			}
		}
		automaton.is_accepting()
	}
}
pub struct Variants {
	state: u32,
}
impl Variants {
	pub const fn new() -> Self {
		Self { state: 0u32 }
	}
	pub const fn push(&mut self, token: char) -> bool {
		self.state = match self.state {
			0u32 => match token {
				'0'..='9' => 1u32,
				'A'..='Z' | 'a'..='z' => 2u32,
				_ => return false,
			},
			1u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 3u32,
				_ => return false,
			},
			2u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 4u32,
				_ => return false,
			},
			3u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 12u32,
				_ => return false,
			},
			4u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 5u32,
				_ => return false,
			},
			5u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 6u32,
				_ => return false,
			},
			6u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 7u32,
				_ => return false,
			},
			7u32 => match token {
				'-' => 8u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 9u32,
				_ => return false,
			},
			8u32 => match token {
				'0'..='9' => 1u32,
				'A'..='Z' | 'a'..='z' => 2u32,
				_ => return false,
			},
			9u32 => match token {
				'-' => 8u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 10u32,
				_ => return false,
			},
			10u32 => match token {
				'-' => 8u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 11u32,
				_ => return false,
			},
			11u32 => match token {
				'-' => 8u32,
				_ => return false,
			},
			12u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 13u32,
				_ => return false,
			},
			13u32 => match token {
				'-' => 8u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 7u32,
				_ => return false,
			},
			_ => return false,
		};
		true
	}
	pub const fn is_accepting(&self) -> bool {
		matches!(self.state, 0u32 | 7u32 | 9u32 | 10u32 | 11u32 | 13u32)
	}
	pub const fn validate_str(s: &str) -> bool {
		Self::validate_bytes(s.as_bytes())
	}
	pub const fn validate_bytes(bytes: &[u8]) -> bool {
		let mut i = 0;
		let mut automaton = Self::new();
		while i < bytes.len() {
			match ::static_automata::decode_utf8_char(bytes, i) {
				Ok((c, len)) => {
					if !automaton.push(c) {
						return false;
					}
					i += len;
				}
				Err(_) => return false,
			}
		}
		automaton.is_accepting()
	}
}
pub struct Extension {
	state: u32,
}
impl Extension {
	pub const fn new() -> Self {
		Self { state: 0u32 }
	}
	pub const fn push(&mut self, token: char) -> bool {
		self.state = match self.state {
			0u32 => match token {
				'0'..='9' | 'A'..='W' | 'Y'..='Z' | 'a'..='w' | 'y'..='z' => 1u32,
				_ => return false,
			},
			1u32 => match token {
				'-' => 2u32,
				_ => return false,
			},
			2u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 3u32,
				_ => return false,
			},
			3u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 4u32,
				_ => return false,
			},
			4u32 => match token {
				'-' => 2u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 5u32,
				_ => return false,
			},
			5u32 => match token {
				'-' => 2u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 6u32,
				_ => return false,
			},
			6u32 => match token {
				'-' => 2u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 7u32,
				_ => return false,
			},
			7u32 => match token {
				'-' => 2u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 8u32,
				_ => return false,
			},
			8u32 => match token {
				'-' => 2u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 9u32,
				_ => return false,
			},
			9u32 => match token {
				'-' => 2u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 10u32,
				_ => return false,
			},
			10u32 => match token {
				'-' => 2u32,
				_ => return false,
			},
			_ => return false,
		};
		true
	}
	pub const fn is_accepting(&self) -> bool {
		matches!(self.state, 4u32 | 5u32 | 6u32 | 7u32 | 8u32 | 9u32 | 10u32)
	}
	pub const fn validate_str(s: &str) -> bool {
		Self::validate_bytes(s.as_bytes())
	}
	pub const fn validate_bytes(bytes: &[u8]) -> bool {
		let mut i = 0;
		let mut automaton = Self::new();
		while i < bytes.len() {
			match ::static_automata::decode_utf8_char(bytes, i) {
				Ok((c, len)) => {
					if !automaton.push(c) {
						return false;
					}
					i += len;
				}
				Err(_) => return false,
			}
		}
		automaton.is_accepting()
	}
}
pub struct ExtensionSubtag {
	state: u32,
}
impl ExtensionSubtag {
	pub const fn new() -> Self {
		Self { state: 0u32 }
	}
	pub const fn push(&mut self, token: char) -> bool {
		self.state = match self.state {
			0u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 1u32,
				_ => return false,
			},
			1u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 2u32,
				_ => return false,
			},
			2u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 3u32,
				_ => return false,
			},
			3u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 4u32,
				_ => return false,
			},
			4u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 5u32,
				_ => return false,
			},
			5u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 6u32,
				_ => return false,
			},
			6u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 7u32,
				_ => return false,
			},
			7u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 8u32,
				_ => return false,
			},
			_ => return false,
		};
		true
	}
	pub const fn is_accepting(&self) -> bool {
		matches!(self.state, 2u32 | 3u32 | 4u32 | 5u32 | 6u32 | 7u32 | 8u32)
	}
	pub const fn validate_str(s: &str) -> bool {
		Self::validate_bytes(s.as_bytes())
	}
	pub const fn validate_bytes(bytes: &[u8]) -> bool {
		let mut i = 0;
		let mut automaton = Self::new();
		while i < bytes.len() {
			match ::static_automata::decode_utf8_char(bytes, i) {
				Ok((c, len)) => {
					if !automaton.push(c) {
						return false;
					}
					i += len;
				}
				Err(_) => return false,
			}
		}
		automaton.is_accepting()
	}
}
pub struct Extensions {
	state: u32,
}
impl Extensions {
	pub const fn new() -> Self {
		Self { state: 0u32 }
	}
	pub const fn push(&mut self, token: char) -> bool {
		self.state = match self.state {
			0u32 => match token {
				'0'..='9' | 'A'..='W' | 'Y'..='Z' | 'a'..='w' | 'y'..='z' => 1u32,
				_ => return false,
			},
			1u32 => match token {
				'-' => 2u32,
				_ => return false,
			},
			2u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 3u32,
				_ => return false,
			},
			3u32 => match token {
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 4u32,
				_ => return false,
			},
			4u32 => match token {
				'-' => 5u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 6u32,
				_ => return false,
			},
			5u32 => match token {
				'0'..='9' | 'A'..='W' | 'Y'..='Z' | 'a'..='w' | 'y'..='z' => 7u32,
				'X' | 'x' => 3u32,
				_ => return false,
			},
			6u32 => match token {
				'-' => 5u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 8u32,
				_ => return false,
			},
			7u32 => match token {
				'-' => 2u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 4u32,
				_ => return false,
			},
			8u32 => match token {
				'-' => 5u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 9u32,
				_ => return false,
			},
			9u32 => match token {
				'-' => 5u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 10u32,
				_ => return false,
			},
			10u32 => match token {
				'-' => 5u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 11u32,
				_ => return false,
			},
			11u32 => match token {
				'-' => 5u32,
				'0'..='9' | 'A'..='Z' | 'a'..='z' => 12u32,
				_ => return false,
			},
			12u32 => match token {
				'-' => 5u32,
				_ => return false,
			},
			_ => return false,
		};
		true
	}
	pub const fn is_accepting(&self) -> bool {
		matches!(
			self.state,
			0u32 | 4u32 | 6u32 | 8u32 | 9u32 | 10u32 | 11u32 | 12u32
		)
	}
	pub const fn validate_str(s: &str) -> bool {
		Self::validate_bytes(s.as_bytes())
	}
	pub const fn validate_bytes(bytes: &[u8]) -> bool {
		let mut i = 0;
		let mut automaton = Self::new();
		while i < bytes.len() {
			match ::static_automata::decode_utf8_char(bytes, i) {
				Ok((c, len)) => {
					if !automaton.push(c) {
						return false;
					}
					i += len;
				}
				Err(_) => return false,
			}
		}
		automaton.is_accepting()
	}
}
